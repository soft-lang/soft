nodetype,primitivetype,nodegroup,precedence,literal,literalpattern,nodepattern,prologue,epilogue,growfrom,growinto,nodeseverity
RET,void,,,,,,,,,,
SOURCE_CODE,text,,,,,,,,,,
BANG_EQ,,OPS,,!=,,,,,,,
LT_EQ,,OPS,,<=,,,,,,,
EQ_EQ,,OPS,,==,,,,,,,
GT_EQ,,OPS,,>=,,,,,,,
LPAREN,,LSEP,,(,,,,,,,
LBRACKET,,LSEP,,[,,,,,,,
LBRACE,,LSEP,,{,,,,,,,
BANG,,OPS,,!,,,,,,,
PERCENT,,OPS,,%,,,,,,,
ASTERISK,,OPS,,*,,,,,,,
PLUS,,OPS,,+,,,,,,,
COMMA,,OPS,,",",,,,,,,
MINUS,,OPS,,-,,,,,,,
DOT,,OPS,,.,,,,,,,
LT,,OPS,,<,,,,,,,
EQ,,OPS,,=,,,,,,,
GT,,OPS,,>,,,,,,,
RPAREN,,RSEP,,),,,,,,,
RBRACKET,,RSEP,,],,,,,,,
RBRACE,,RSEP,,},,,,,,,
SEMICOLON,,SEP,,;,,,,,,,
WHITE_SPACE,,,,,(\s+),,,,,,
NUMERIC,numeric,VALUE,,,([0-9]+(?:\.[0-9]+)?),,,,,,
INTEGER,integer,VALUE,,,^([0-9]+)$,,,,NUMERIC,,
IDENTIFIER,name,VALUE,,,([a-zA-Z_][0-9a-zA-Z_]*),,,,,,
IF,,,,,^(if)$,,,,IDENTIFIER,,
ELSE,,SEP,,,^(else)$,,,,IDENTIFIER,,
FUNCTION,,,,,^(fun)$,,,,IDENTIFIER,,
LET,,,,,^(var)$,,,,IDENTIFIER,,
RETURN,,SEP,,,^(return)$,,,,IDENTIFIER,,
BOOLEAN,boolean,VALUE,,,^(true|false)$,,,,IDENTIFIER,,
AND,,OPS,,,^(and)$,,,,IDENTIFIER,,
OR,,OPS,,,^(or)$,,,,IDENTIFIER,,
NIL,nil,VALUE,,,^(nil)$,,,,IDENTIFIER,,
SUPER,,VALUE,,,^(super)$,,,,IDENTIFIER,,
THIS,,VALUE,,,^(this)$,,,,IDENTIFIER,,
CLASS,,,,,^(class)$,,,,IDENTIFIER,,
FOR,,,,,^(for)$,,,,IDENTIFIER,,
PRINT,,SEP,,,^(print)$,,,,IDENTIFIER,,
WHILE,,,,,^(while)$,,,,IDENTIFIER,,
SLASH,,OPS,,,(/)(?=[^/]|$),,,,,,
COMMENT,,,,,(//[^\n\r]*),,,,,,
TEST_EXPECTED_STDOUT,,,,,^(// (?:expect: |Error|\[(?:java )?line \d+\] Error|(?:// )?expect runtime error: ).*)$,,,,COMMENT,,
TEXT,text,VALUE,,,"("")((?:[^""\\]|\\.)*)("")",,,,,,
ILLEGAL,,,,,(.),,,,,,ERROR
VARIABLE,name,,,,,FUNCTION LPAREN (IDENTIFIER) | (IDENTIFIER) LPAREN (?:IDENTIFIER (?:COMMA IDENTIFIER)*)? RPAREN LBRACE | VARIABLE LPAREN (IDENTIFIER) | VARIABLE COMMA (IDENTIFIER) | LET (IDENTIFIER) (?:EQ|SEMICOLON) | CLASS (IDENTIFIER),,,,,
CONDITION,,SEP,,,,IF (SUB_EXPRESSION),,,,,
PARAMETERS,,,,,,(LPAREN (?:VARIABLE (?:COMMA VARIABLE)*)? RPAREN) LBRACE,,,,,
FUNCTION_DECLARATION,,,,,,(?:FUNCTION)? VARIABLE (PARAMETERS (?:BLOCK_EXPRESSION | BLOCK_STATEMENT)),,RET,,,
INITIALIZATION,,SEP,,,,LET VARIABLE (EQ),,,,,
EXPECT_DOT_AFTER_SUPER,,,,,,(SUPER (?:(?!DOT)[A-Z_]+ | $)),,,,,ERROR
SUPERCLASS,name,,,,,CLASS VARIABLE (LT IDENTIFIER),,,,,
WHILE_EXIT_CONDITION,boolean,SEP,,,,(WHILE SUB_EXPRESSION),,,,,
TRUE_BRANCH,,,,,,CONDITION (STATEMENT | BLOCK_EXPRESSION | VALUE SEMICOLON ),,,,,
FALSE_BRANCH,,,,,,ELSE (STATEMENT | BLOCK_EXPRESSION | VALUE SEMICOLON ),,,,,
DECLARATION,void,STATEMENT,,,,(LET VARIABLE (?:SEMICOLON | INITIALIZATION EXPRESSION (?:SEMICOLON)?) | FUNCTION VARIABLE FUNCTION_DECLARATION | CLASS VARIABLE CLASS_DECLARATION),,,,,
CALL_LPAREN,,,,,,(?:(?#VALUE) | (?#RSEP)) (LPAREN),,,,,
CLASS_DECLARATION,,,,,,CLASS VARIABLE ((?:SUPERCLASS)? LBRACE (?:VARIABLE FUNCTION_DECLARATION)* RBRACE),,,,,
VALUE,,,,,,(?:^ | (?!VARIABLE FUNCTION_DECLARATION)[A-Z_]+) ((?#VALUE)),,,,,
ARGUMENTS_EXPRESSION,,OPS,,,,(CALL_LPAREN (?:VALUE | (?#OPS))* RPAREN),,,VALUE,,
IF_EXPRESSION,,STATEMENT,,,,(IF CONDITION TRUE_BRANCH (?:ELSE FALSE_BRANCH)?) (?!ELSE)(?=[A-Z_]+ | $),,,,,
BLOCK_EXPRESSION,,VALUE,,,,(LBRACE (?:STATEMENT)* (?:VALUE | EXPRESSION) RBRACE),,,,,
VALUE_STATEMENT,,STATEMENT,,,,(VALUE) VALUE,,,,,
SUB_EXPRESSION,,VALUE,,,,(LPAREN (?:VALUE | (?#OPS))+ RPAREN),,,VALUE,,
EXPRESSION,,,,,,(?:^ | (?#SEP) | (?#LSEP)) ((?:VALUE | (?#OPS))+) (?:(?#RSEP) | (?#SEP) | $),,,VALUE,,
ARGUMENTS,,,,,,(CALL_LPAREN (?:VALUE (?:COMMA VALUE)*)? RPAREN),,,,VALUE,
INDEX,,,,,,(VALUE INDEX_KEY),,,,VALUE,
GET,,,,,,(VALUE DOT VALUE),,,,VALUE,
CALL,,,,,,(VALUE ARGUMENTS_EXPRESSION),,,,VALUE,
GROUP,,,,,,(?:^ | (?#OPS)) (LPAREN VALUE RPAREN),,,,VALUE,
NOT,,,PREFIX,,,(BANG VALUE),,,,VALUE,
UNARY_MINUS,,,PREFIX,,,(?:^ | (?!(?:VALUE | RPAREN))[A-Z_]+) (MINUS VALUE),,,,VALUE,
DIVIDE,,,PRODUCT,,,(VALUE SLASH VALUE),,,,VALUE,
MULTIPLY,,,PRODUCT,,,(VALUE ASTERISK VALUE),,,,VALUE,
ADD,,,SUM,,,(VALUE PLUS VALUE),,,,VALUE,
SUBTRACT,,,SUM,,,(VALUE MINUS VALUE),,,,VALUE,
GREATER_THAN,,,LESSGREATER,,,(VALUE GT VALUE),,,,VALUE,
GREATER_THAN_OR_EQUAL_TO,,,LESSGREATER,,,(VALUE GT_EQ VALUE),,,,VALUE,
LESS_THAN,,,LESSGREATER,,,(VALUE LT VALUE),,,,VALUE,
LESS_THAN_OR_EQUAL_TO,,,LESSGREATER,,,(VALUE LT_EQ VALUE),,,,VALUE,
EQUAL,,,EQUALS,,,(VALUE EQ_EQ VALUE),,,,VALUE,
NOT_EQUAL,,,EQUALS,,,(VALUE BANG_EQ VALUE),,,,VALUE,
LOGICAL_AND,,,,,,(VALUE AND VALUE),,,,VALUE,
LOGICAL_OR,,,,,,(VALUE OR VALUE),,,,VALUE,
ASSIGNMENT,,,,,,(VALUE EQ VALUE) (?:RPAREN | $),,,,VALUE,
INVALID_EXPRESSION,,,,,,^(?!VALUE$)((?:[A-Z_]+)+)$,,,,VALUE,ERROR
PRINT_STATEMENT,,STATEMENT,,,,(PRINT EXPRESSION SEMICOLON),,,,,
RETURN_STATEMENT,,STATEMENT,,,,(RETURN (?:EXPRESSION (?:SEMICOLON)? | SEMICOLON)),,,,,
FOR_INIT,,SEP,,,,(FOR LPAREN (?:DECLARATION | EXPRESSION_STATEMENT | SEMICOLON)),,,,,
FOR_EXIT_CONDITION,boolean,SEP,,,,FOR_INIT (EXPRESSION_STATEMENT | SEMICOLON),,,,,
FOR_INCREMENT_STEP,void,SEP,,,,FOR_EXIT_CONDITION ((?:EXPRESSION)? RPAREN),,,,,
FOR_BODY,void,,,,,FOR_INCREMENT_STEP (STATEMENT),,,,,
FOR_STATEMENT,,STATEMENT,,,,(FOR_INIT FOR_EXIT_CONDITION FOR_INCREMENT_STEP FOR_BODY),,,,,
WHILE_BODY,void,,,,,WHILE_EXIT_CONDITION (STATEMENT),,,,,
WHILE_STATEMENT,,STATEMENT,,,,(WHILE_EXIT_CONDITION WHILE_BODY),,,,,
BLOCK_STATEMENT,,STATEMENT,,,,(LBRACE (?:STATEMENT)* RBRACE),,,,,
EXPRESSION_STATEMENT,,STATEMENT,,,,(EXPRESSION SEMICOLON),,,,,
STATEMENT,,SEP,,,,((?#STATEMENT)),,,,,
STATEMENTS,,,,,,((?:STATEMENT)+ (?:EXPRESSION)? | EXPRESSION),,,,,
UNPARSEABLE,,,,,,(?!STATEMENTS | UNPARSEABLE | PROGRAM)([A-Z_]+),,,,,ERROR
PROGRAM,,,,,,((?:STATEMENTS | UNPARSEABLE)+),,RET,,,
